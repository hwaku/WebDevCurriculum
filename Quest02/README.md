# Quest 02. CSS의 기초와 응용

---

## Checklist
### CSS를 HTML에 적용하는 세 가지 방법과 각각 장단점은?
* Inline Style Sheet : HTML 태그의 style 속성에 CSS 코드를 넣는 방법
    * 장점
        * 쉽고 빠르게 CSS 룰을 삽입할 수 있어 테스팅, 변경사항 테스트, 빠른 수정이 가능하다.
        * 별도의 문서로 외부 스타일을 만들거나 업로드 할 필요가 없다.
    * 단점
        * 룰을 모든 HTML에 재사용 할 수 없기때문에 시간이 오래걸리고 구조를 복잡하게 만든다.
        * 여러 엘리먼트에 룰을 적용하면 웹페이지 사이즈와 다운로드 시간에 영향을 줄 수 있다.

- Internal Style Sheet :  HTML 문서 안의 `<style>`과 `</style>` 안에 CSS 코드를 넣는 방법
    * 장점
        * 스타일 시트에 선택자를 사용할 수 있다.
        * 동일한 HTML 파일 내에서만 코드를 추가하기 때문에 여러 파일을 업로드할 필요가 없다.
    * 단점
        * 다른 HTML 문서에는 적용할 수 없다.
        * HTML 문서에 코드를 추가하는 것은 페이지의 사이즈와 로딩 시간을 증가시킬 수 있다.

* Linking Style Sheet :  별도의 CSS 파일을 만들고 HTML 문서와 연결하는 방법
    * 장점
        * CSS 코드가 별도의 문서로 있기 때문에 HTML 파일의 구조가 깔끔해지고 사이즈가 작아진다.
        * CSS를 적용시키고 싶은 여러 문서에 <link> 태그를 통해 연결만 해주면 사용가능하다.
    * 단점
        * 외부 CSS 파일이 로드되기 전까지 페이지가 올바르게 표시되지 않는다.
        * 여러 CSS 파일을 업로드 하거나 연결하면 사이트 다운로드 시간이 증가할 수 있다.

### CSS 규칙의 우선순위는 어떻게 결정될까?
1. 속성 값 뒤에 `!important`를 붙인 속성
2. `HTML`에서 `<style>`을 직접 지정한 속성
3. `#id`로 지정한 속성
4. `.클래스`, `:추상클래스`로 지정한 속성
5. `태그이름`으로 지정한 속성
6. 상위 객체에 의해 **상속**된 속성
  
### CSS의 박스모델은 무엇일까? 박스가 화면에서 차지하는 크기는 어떻게 결정될까?
* 모든 HTML 요소는 박스(box) 모양으로 구성되며, 이것을 박스 모델(box model)이라고 부른다.
* 박스 모델은 HTML 요소를 패딩(padding), 테두리(border), 마진(margin), 그리고 내용(content)로 구분한다.
  * 내용(content) : 텍스트나 이미지가 들어간 실제 내용
  * 패딩(padding) : 내용과 테두리 사이의 간격(여백)
  * 테두리(border) : 내용과 패딩 주변을 감싸는 테두리
  * 마진(margin) : 테두리와 상위 요소의 간격

### `float` 속성은 왜 좋지 않을까?
1. 애초에 레이아웃 정렬을 위해 설계된 속성이 아니다. `float`는 이미지 정렬을 위한 스타일이다.
2. 요소의 높이가 제각각일 때 정렬이 깨질 수 있다.
3. `float`는 요소의 흐름을 관리하는 속성이기때문에 속성이 다음 요소로 상속되어 적절한 위치에서 매번 clear 해줘야 한다.

### Flexbox(Flexible box)와 CSS Grid의 차이와 장단점은 무엇일까?
  
    Flexbox는 1차원 레이아웃이라고 불리며, 플렉스 컨테이너 속 요소들을 가로 세로 유연하게 배치할 수 있다.
    CSS Grid는 2차원 레이아웃이라고 불리며, 가로 세로 격자를 만들어 그속에 요소들을 배치한다.
    즉, Flexbox는 요소를 직접 배치시키는 반면에 Grid는 미리 레이아웃을 짜놓고 요소들을 배치한다.

### CSS의 비슷한 요소들을 어떤 식으로 정리할 수 있을까?
  
비슷한 요소들끼리 묶음을 만들어 관리하면 편하다.

## Advanced
### 왜 CSS는 어려울까요?
  
    CSS 규칙의 상호작용을 모두 알기 어려우며 어떤 규칙이 최종적으로 적용될지 예측하기 어렵다.
    또한 런타임에 따라도 변화하기때문에 더욱 결과물에 대한 예측이 어렵기 떄문이다.

### CSS의 어려움을 극복하기 위해 어떤 방법들이 제시되고 나왔을까요?
  
    CSS 규칙의 최정 적용 예측은 BEM(이름이 중복되지 않도록 CSS 아이디와 클래스를 명명하는 방법론)을
    도입하고 CSS Modules(각 파일에 선언된 CSS 선택자에 고유한 해시 문자열을 추가하여, 해당 선택자가 각 파일의 
    네임스페이스에서만 동작하도록 자동적으로 관리)을 사용함으로써 극복할 수 있다.
    
    CSS의 규칙의 상호작용은 경험을 통한 습득을 해야하는 부분이고 런타임 부분은 현실을 직시하여 특정 런타임 환경을
    대상으로 확정하고 확실히 지원할 수 있는 방향으로 나아가야한다.

### CSS가 브라우저에 의해 해석되고 적용되기까지 내부적으로 어떤 과정을 거칠까요?
  
    브라우저 HTML 로드 > HTML을 DOM(Document Object Model)로 변환 > HTML 문서에 연결된 리소스와 CSS를 가져옴
    > 가져온 CSS를 분석하여 선택자 유형별로 다른 규칙을 "buckets"로 정렬, 선택자 기반으로 DOM의 어느 노드에
    어떤 규칙을 적용해야하는지 결정하고, 필요에 따라 스타일을 첨부 > 규칙이 적용된 후 render tree가 표시될 수 있는 구조 배치
    > 화면에 출력(painting) 단계들을 거친다.

### 웹 폰트의 경우에는 브라우저 엔진 별로 어떤 과정을 통해 렌더링 될까요?_
  
    HTML을 DOM로 변환하고 CSS를 가져오는과정에서 웹 폰트를 다운로드하기 시작한다. 출력(painting)시 웹 폰트의 다운로드가
    완료되지 않았다면 해당 폰트를 사용하는 콘텐츠의 렌더링을 차단한다.
    브라우저에서 웹 폰트 렌더링을 차단하는 방법은 2가지로 나뉜다. IE는 FOUT(Flash of Unstyled Text) 방식을 따르고,
    그 외 브라우저는 FOIT(Flash of Invisible Text) 방식을 따른다.
    여기서 FOIT은 해당 폰트가 적용된 텍스트 영역을 여백으로 먼저 처리하고 로딩이 완료되면 해당 폰트를 적용한다. 하지만
    3초의 제한 시간이 있어 로딩이 3초를 넘어가면 폴백 폰트로 렌더링 한다.
    FOUT은 폴백 폰트를 먼저 표시하고, 웹 폰트 로딩이 완료되면 해당 폰트를 적용한다.
    위에서 폴백 폰트는 가변 글꼴(대체 폰트)을 말한다.